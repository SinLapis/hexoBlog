---
title: Java编程思想笔记0x00
date: 2019-06-25 18:43:55
categories: Java
tags:
  - Java
  - 笔记
---

# 对象

## 面向对象的程序设计方式

1. 万物皆对象
2. 程序是对象的集合，它们通过发送消息来告知彼此要做的。
3. 每个对象都有自己的、由其他对象所构成的存储
4. 每个对象都有其类型
5. 某一特定类型的所有对象都可以接受同样的消息

## 封装

- 只向客户端程序员暴露必须的部分，而隐藏其它部分
- 原因：
  1. 让客户端程序员无法触及他们不应该触及的部分，关注对他们来说关键的东西。
  2. 允许库设计者可以改变类内部的工作方式而不必担心会影响到客户端程序员。

## 继承

- 继承使用基类型和导出类型的概念表示了类型间的相似性。

## 多态

- 后期绑定：当向对象发送消息时，被调用代码直到运行时才能确定。编译器确保被调用方法存在，并对调用参数和返回值执行类型检查，但并不知道被执行的确切代码。
- 向上转型：在程序执行过程中，把导出类看做其基类的过程。

## 基本类型

- 基本类型的创建：创建一个并非是引用的“自动”变量，这个变量直接存储值并置于堆栈中。
- 基本类型占用的存储空间不随机器硬件架构变化而变化
- 所有的数值类型都有正负号

## static

- 当声明一个事物是```static```时，就意味着这个域或方法不会与包含它的那个类的任何对象实例关联在一起。即使从未创建过某个类的任何对象，也可以调用其```static```方法或访问其```staic```域。
- 在```static```内部不能调用非静态方法。

# 初始化与清理

## 构造器

- 构造器是一种特殊类型的方法，因为它没有返回值。这与返回值为空是不同的。```new```表达式返回了对象的引用，但这并不是构造器的返回值。
- 构造器中对变量的初始化会覆盖该变量在定义时的初始化
- 如果类中没有构造器，那么编译器会自动创建一个默认的构造器，但是如果已经定义类一个构造器，无论是否有参数，编译器就不再创建默认构造器。

## 重载

- 如果传入的数据类型小于方法中声明的形式参数类型，实际数据的类型就会提升。但是```char```型略有不同，如果无法找到恰好接受```char```型的方法，就会把```char```直接提升到```int```型。

## 初始化

- 静态初始化只在必要的时候进行。如果不创建对象，或者不访问静态域，那么就不会进行静态初始化。
- 初始化的顺序是先静态对象，后其它对象。

## 可变参数列表

- 可以使用类似```Object... args```的参数形式来代替显示的声明数组。

# 访问权限控制

## 代码组织

- 一个Java源文件称为编译单元。一个编译单元中只能有一个public类，且该类的名称需与文件名称相同（包括大小写，不包括文件名后缀）。
- 类库中会有一组类文件，每个文件都由一个public类和任意数量的非public类组成，因此每个文件都由一个构件。如果希望这些构件从属于同一个群组，可以使用关键字```package```。

## 访问权限

- 包访问权限：是默认的访问权限，意味着当前包中的所有其它类对该成员都有访问权限。
- 默认包：如果没有给Java文件设置任何包名称，则编译器会把处于相同目录下的Java文件看作是属于该目录下的默认包之中。
- ```public```：由```public```修饰的成员对任何类都是可用的。
- ```private```：由```private```修饰的成员，除了包含该成员的类以外，其它任何类都无法访问这个成员。
- 如果使用```privatge```修饰构造器，那么将无法通过通常手段进行对象的创建，并且会阻碍对此类的继承。
- ```protected```：由```protected```修饰的成员仅支持当前类、继承类以及相同包的其它类访问（即提供包访问权限）

# 复用类

## 组合

## 继承

- 继承中的构建：在继承中，构建过程是从基类流向导出类的，因此基类在导出类构造器可以访问它之前就已经完成了初始化。即使导出类没有显式创建构造器，编译器也会自动创建一个默认的构造器，该构造器将调用基类的构造器。但是如果基类设置了有参构造器，那么在导出类中如果不显示声明调用基类的某个构造器，在创建过程中将会默认调用基类的无参构造器，如果基类没有声明无参构造器则编译不会通过。

## 代理

- 将一个成员对象置于要构造的类中，同时在新类中暴露该类所有的成员方法。

## final

- 使用```final```修饰的基本类型变量值不能改变，如果是引用类型变量则引用值不能改变，但是引用指向的对象自身是可以改变的。此外，使用```final```修饰的变量必须初始化（可以在声明时初始化或者在构造器中初始化）。
- 一个既是```static```又是```final```的变量只能占据一段不能改变的存储空间，并且必须在声明时初始化。
- 只有想要明确禁止覆盖方法时，才将方法设为final。

# 多态

- 协变返回类型：在导出类中的被覆盖方法可以返回基类方法的返回类型的某种导出类。

# 接口

## 抽象类

- 抽象类和抽象方法可以使类的抽象性明确起来，并且可以明确传达类的使用方法。此外，抽象类还是有用的重构工具。

## 接口

- 当组合接口时，如果存在两个方法重名、参数列表或返回值不一致，那么会产生冲突。





