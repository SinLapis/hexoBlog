---
title: Java编程思想笔记0x03
date: 2019-06-28 20:48:30
categories: Java
tags:
  - Java
  - 笔记
---

# 通过异常处理错误

## 基本异常

- 异常是指组织当前方法或作用于继续执行的问题
- 与普通问题对比：普通问题在当前环境中能得到足够的信息，总能处理错误，而对于异常则在当前环境中无法获得足够信息来解决问题。
- 抛出异常：从当前环境跳出，并且把问题交给上一级环境
- 异常参数：异常类有两个构造器，一个是默认构造器，另一个接受一个字符串参数，能够输入自定义的错误信息

## 捕获异常

### try块

- 如果不希望在方法内遇到异常就结束，可以使用`try`包裹可能出现异常的代码来捕获异常
- 相较于不支持处理异常的语言，`try`可以不需要在每一次调用方法的前后设置错误检查的代码，从而使代码更容易编写和阅读

### 异常处理程序

- 用于处理`try`捕获的异常，关键字为`catch`，参数为错误类型以及标识符。

### 终止与恢复

- 终止模型：假设错误非常关键，以至于程序无法返回到异常发生的地方继续执行
- 恢复模型：异常处理程序的工作是修正错误，然后重新尝试调用出问题的方法，并任务第二次能成功
- 尽管恢复模型显得很吸引人，但是并不实用。其中的主要原因可能是它所导致的耦合：恢复性的处理程序需要了解异常抛出的地点，这势必要包含依赖于抛出位置的非通用代码。

## 自定义异常

- 自定义异常需要从已有的异常类继承，最好是选择意思相近的异常类继承，也可以选择编程相关的所有异常的父类`Exception`继承。

## 异常说明

- 在方法声明中，形式参数列表后使用关键字`throw`，后面接一个所有潜在异常类型的列表，可以表示该方法可能会抛出相应的异常。调用此方法时，如果没有处理这些异常将无法通过编译。

## 捕获所有异常

- 捕获时，使用`Exception`类可以捕获到所有编程相关的异常。最好将其放在处理程序的末尾，以防它抢在其它异常处理程序之前把异常捕获了。
- 栈轨迹：异常对象的`getStackTrace()`可以获得发生错误时调用序列，栈顶是调用序列中最后一个方法调用。
- 重新抛出异常：在`catch`块中可以使用`throw`重新抛出异常，将异常抛给上一级环境中的异常处理程序，后续的`catch`子句将被忽略。

### 异常链

- 异常链是指在捕获一个异常后抛出另一个异常，并且希望保存原始异常的信息。
- `Throwable`的构造器可接受另一个`Throwable`对象作为原始异常（`cause`）来追踪异常最初发生的位置。
- `initCause()`方法可以为一个没有设置原始异常的`Throwable`对象设置原始异常。注意此方法仅能调用一次，并且如果该对象已经通过构造器设置原始异常或者该方法调用超过一次，那么会抛出`IllegalStateException`。

## Java标准异常

- 运行时异常（`RuntimeException`），例如空指针异常（`NullPointerException`）会被Java虚拟机自动抛出，不需要在异常说明中添加这类异常，如果没有被捕获，它们将直达`main()`方法。

## 使用finally清理

- `finally`子句中的代码无论`try`块中是否抛出异常都会得到执行。
- 当要把除内存之外的资源恢复到它们的初始状态时，可以使用`finally`子句。例如关闭打开的文件或者网络连接等。
- 丢失异常：`try`块中的异常会被`finally`子句中的异常覆盖；如果在`finally`子句中返回，即使抛出异常也不会产生输出。