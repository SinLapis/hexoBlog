---
title: Java8实战笔记0x03
date: 2019-08-08 20:08:34
categories: Java
tags:
  - Java
  - 笔记
---

# 并行数据处理与性能

## 并行流

### 将顺序流转换为并行流

- 可以把流转换成并行流，从而让前面的函数归约过程并行运行。对顺序流调用`parallel()`方法。

```java
public static long parallelSum(long n) {
    return Stream.iterate(1L, i -> i + 1)
        .limit(n)
        .parallel()
        reduce(0L, Long::sum);
}
```

- 对顺序流调用`parallel()`方法不意味着流本身有任何实际的变化。它内部实际上就是设了一个`boolean`标志，表示让调用`parallel()`方法之后进行的所有操作都并行执行。类似的，对并行流调用`sequential()`方法就可以把它变成顺序流。不过在一个流水线中，只有最后一个`parallel()`或者`squential()`方法生效，影响整个流水线。

### 高效使用并行流

- 首先应该进行**测量**。并行流并不总是比顺序流快。
- 留意**装箱**。自动装箱合拆箱操作会大大降低性能。可以使用原始类型流（`IntStream`、`LongStream`、`DoubleStream`）来避免这种操作。
- 有些操作**本身在并行流上的性能就比顺序流差**，特别是`limit`和`findFirst`等依赖于元素顺序的操作，它们在并行流上执行的代价非常大。
- 要考虑流的操作流水线的**总计算成本**。设`N`是要处理的元素总数，`Q`是一个元素通过流水线的大致处理成本，则`N*Q`就是这个对成本的一个粗略估计。Q值较高就意味着使用并行流时性能好的可能性比较大。
- 对于较小的数据量，选择并行流几乎不是一个好的决定。并行处理少数几个元素的好处还抵不上**并行化造成的额外开销**。
- 要考虑**流背后的数据结构是否容易分解**。例如`ArrayList`的拆分效率比`LinkedList`高得多，因为前者不用遍历就可以平均拆分，后者则必须遍历。
- 流自身的特点，以及流水线中的中间操作修改流的方式，都可能会**改变分解过程的性能**。例如一个流可以分成大小相同的两部分，这样每个部分都可以比较高效地并行处理，但筛选操作可能会丢弃的元素个数却无法预测，导致流的大小未知。
- 要考虑终端操作中合并步骤的代价。如果代价很大，那么组合每个子流产生的部分结果所付出的代价就可能会超过通过并行流得到的性能提升。

## 分支/合并框架

