# 1 MongoDB简介

MongoDB是一个面向文档的数据库，与传统的关系型数据库不同，MongoDB中没有行的概念，取而代之的是文档中的内容和数组。这种形式可以灵活的表现各种复杂的层次关系，加快开发者开发进程。

<!-- more -->

当数据积累到一定程度，当前的服务器性能不足以胜任计算性能和存储空间要求时，应当进行数据库的纵向扩展或者横向扩展。纵向扩展是指单纯提高服务器的硬件性能，横向扩展是指向服务器集群中添加更多的服务器。显然纵向扩展是有极限的，而MongoDB可以进行较为方便的横向扩展，以提高数据库集群的计算能力以及存储空间。

MongoDB支持索引、聚合、特殊的集合类型、文件存储的功能，但是例如连接和复杂的多行事物等是不支持的，这是由于这些功能不方便在分布式系统上实现。

# 2 基础部分

## 2.1 文档

文档是一组有序键值对的集合。注意：（1）键中不能含有`\0`（表示字符串结尾），`.`和`$`有特殊含义，不能随意使用；（2）键不能重复；（3）键字符串可以是任意utf-8符号。

## 2.2 集合

集合是一组文档。虽然可以将不同结构的文档，但是出于方便管理、为集合建立索引以及查询性能的考虑，建议把同种结构、包括同类内容的文档归入同一集合内。这也是为什么设计集合的原因。

类似于文档键的命名规则，集合名的命名规则有：（1）不能为`""`；（2）不能包含`\0`、`$`；（3）不能以`system.`开头，这些事系统集合的保留前缀。

可以用`.`来进行子集合的组织，构成各种不同的集合子命名空间。

## 2.3 数据库

数据库由多个集合组成。每个数据库都是独立的，无论是权限还是磁盘存储位置。

与集合名、文档键名类似，数据库名也有相应的命名规则：（1）不能为`""`；（2）不能包含`\`、`/`、`*`、`"`、`<`、`>`、`|`、`?`、` `、`$`、`\0`，推荐使用ASCII中的字母和数字；（3）区分字母大小写，简单起见，均使用小写字母；（4）数据库名最长为64字节。

有一些数据库名是保留的，它们有相应的功能：（1）admin：如果将一个用户加入该数据库，它将获得所有数据库的权限，另外有一些指令必须从admin数据库中启动；（2）local：所有本地的集合都会存到这个数据库中，此外，该数据库不能复制；（3）config：分片信息会保存到这个数据库中。

## 2.4 安装MongoDB以及启动

安装环境为CentOS 7。

添加官方源到`/etc/yum.repos.d/mongo-2.6.repo`：

```

[mongodb-org-2.6]
name=MongoDB Repository
baseurl=https://repo.mongodb.org/yum/redhat/$releasever/mongodb-org/2.6/x86_64/
gpgcheck=1
enabled=1
gpgkey=https://www.mongodb.org/static/pgp/server-2.6.asc

```

使用`yum`开始安装：

```shell

yum -y install mongodb-org

```

启动MongoDB服务：

```shell

systemctl start mongod

```

## 2.5 MongoDB shell

MongoDB的shell包含Google的V8引擎，可以执行JavaScript代码，支持JavaScript标准库。打开shell时将会自动连接到本地的MongoDB服务器，也可以指定连接到远端的MongoDB服务器。此外，MongoDB的shell也提供一些方便的语法糖，供习惯于SQL shell的用户使用。

<!-- more -->


## 2.6 数据类型

MongoDB中包含JSON中的几种基本数据类型，还包括了一些其他的扩展类型，以下举出常用的数据类型：
（1）null：空值或值不存在；
（2）布尔值：true或false；
（3）数值：shell中默认使用64位的浮点数，如果想表示整数，可以使用整数类`NumberInt`（4字节有符号整数）或`NumberLong`（8字节有符号整数）；
（4）字符串：utf-8的字符串；
（5）日期：`Date`类，使用`new Date()`创建；
（6）正则表达式：与JavaScript的正则表达式相同；
（7）内嵌文档：将一个文档作为另一个文档的值；
（8）对象id：`ObjectId`类，作为文档的唯一标识；
（9）数组：由一系列可以不同类型的数据构成。

关于日期：如果不使用`new Date()`创建日期对象而使用形如`Date(...)`的构造函数，返回的将是字符串而不是毫秒数。

关于内嵌文档：内嵌文档可以让数据存储更加自然、高效、立体。例如：

```json

{
  "name": "Joe",
  "address": {
    "street": "123 Park Street",
    "city": "X town",
    "state": "NY"
  }
}
```

如果将这段数据存入关系型数据库中，一般来说会拆分成复数个表，会比较复杂。但是，MongoDB如此做的缺点是造成数据冗余。例如某城市的拼写有误，在关系型数据库中只需要修改城市表中有误的项，而对于MongoDB来说则是对属于该城市的每个人的信息进行修改。

关于`_id`：在MongoDB中，每个文档都必须有`_id`，其值可以是任意类型的任何值。在同一个集合的不同文档，其`_id`不能相同。

关于`ObjectId`：这是一种轻量型生成ID的类，可以在不同的机器上使用同种方法生成全局唯一的ID。由于传统数据库中使用的自增主键很难在分布式数据库中同步生成，所以MongoDB采用了这种方法。

`ObjectId`构成：`ObjectId`占用12字节的空间，其中0-3字节是秒级的时间戳，标明文档的创建时间；4-6字节是机器名的hash值，以保证不同机器产生的`ObjectId`不同；7-8字节是PID，以保证在同一机器上并发的进程产生的文档的`ObjectId`不同；9-11字节是一个自增的计数器，以保证同一进程在1秒内创建的文档的`ObjectId`不同，一个进程在一秒内最多可以拥有2563个不同的`ObjectId`。

插入文档时如果没有`_id`，系统会自动生成`ObjectId`。虽然可以由MongoDB服务器来做这件事，但通常是由客户端的驱动程序来完成。这体现了MongoDB的哲学理念：能交给客户端驱动程序做的事就不要交给服务器来做。因为扩展应用层比扩展数据库层简单很多，将部分工作交给客户端来完成，也能够减少服务器的负担。

# 3 创建、更新和删除文档

## 3.1 插入并保存文档

批量插入：除了使用`insert`插入单条数据，还可以使用`batchInsert`进行批量插入，它接受一个文档数组。MongoDB接受的最长消息为48MB，如果超过48MB，多数的驱动程序会将插入请求拆分成多个。如果在插入的过程中某个文档插入错误，则这个文档之前的文档均插入成功，之后的文档均插入失败。可以设置`continueOnError`参数，跳过插入有误的文档，继续进行插入。所有的驱动程序均支持该参数，但shell不支持。

插入校验：插入文档时，会进行基本的数据校验，例如检查有没有`_id`字段，没有则会自动生成一个；会检查文档的大小，单个文档的大小不能超过16M，以防止不良的设计模式，保持性能的一致；会检查有误非utf-8字符存在等等。但尽管如此，向MongoDB中插入非法数据是十分容易的，所以应当只允许信任源连接数据库是必要的。

## 3.2 删除文档

使用`remove()`进行文档删除时，会删除集合中的所有文档，但不会删除集合本身，以及集合的元信息。`remove()`也可以接受一个条件参数，来删除指定的文档。删除时永久性的，不可撤销，也不可恢复。

使用`drop()`的删除速度要远远超过`remove()`，但是如此之后集合也会被删除，也不能指定条件。

## 3.3 更新文档

更新`update()`可以接收两个参数，一个是查询条件，即需要修改哪个文档；另一个是需修改的内容。更新操作时不可分割的。如果有两个更新同时发生，则请求先到达服务器的先执行。系统则会保留最后的更新。`update`的第三个参数是`upsert`，类型为布尔值，为`true`则在查询过程中若没有找到符合条件的文档时会进行创建。第四个参数是是否修改查询得到的全部文档，默认为`false`，即只修改查询得到的第一个文档。

默认情况下，`update`中需修改的内容会被认为是替换原有文档，但是如果希望仅针对文档中的某键值修改的话，可以使用修改器，例如：

```js

db.analytics.update(
  {"url": "www.example.com"},
  {"$inc": {"pageviews": 1}}
)

```

不同的修改器修改文档的速度是不同的。例如只修改值的`$inc`修改器修改速度很快，因为不需要改变文档大小。但是可以修改文档大小的——例如`$set`——就会比较慢，由于MongoDB是给每个文档固定长度的存储空间，如果文档变大进而不能再原先位置存储，还需要移动的磁盘上的其他位置。文档有一个填充因子的参数，用于文档大小的增长。如果一个文档多次因变大而在磁盘上移动，则该文档的填充因子同样会增长。

一个修改操作中不能含有多个修改器，例如在某个修改请求中同时含有`$inc`和`$set`，这个请求就是非法的。

为防止多个线程/进程修改同一个文档而导致竞态，MongoDB提供了一个`findAndModify`方法，其查找和修改是原子操作，不会出现竞态。`findAndModify`不仅可以用于`update`，也可以用于`remove`。

写入安全：分为应答式写入和非应答式写入。应答式写入是指客户端提出写入请求后等待服务端返回写入结果，非应答式写入则相反。

# 4 查询

## 4.1 find

在MongoDB中，使用`find()`来进行查询操作。第一个参数是查询条件，类型为文档，其中包括希望返回结果满足的键值对的要求。如果有对个键值对，将视为“与”进行查询。

`find()`的第二个参数为希望返回/不返回的键，类型为文档，键即文档的键，值为1则返回该键值对，值为0则不返回该键值对。`_id`默认是返回的，如果不希望返回`_id`，可以使用`"_id": 0`。

## 4.2 查询条件

除了精确查询以外，还可以使用`$lt`、`$lte`、`$gt`、`$gte`来进行范围查询，它们分别表示`<`、`<=`、`>`、`>=`。例如：

```json

{
  "age": {
    "$gt": 18,
    "$lt": 30
  }
}

```

上述查询条件表示查找键名`"age"`值大于18小于30的文档。另外，`$ne`表示不相等。

关于`$in`、`$nin`：如果希望能查找某个键对应的多个值，可以使用`$in`。`$in`的参数为一个数组，数组中的值可以为任何类型，MongoDB会查找所有该键的值在数组中的文档。`$nin`则相反，会返回所有该键的值不在数组中的文档。

关于`$or`：`$or`可以进行不同键的“或”查询。和`$in`类似，其参数为一个数组，不过数组中的值均为文档类型。文档中即普通的查询条件。

`$not`：`$not`会返回所有不符合参数中查询条件的文档。和`$and`、`$or`都被称为“元操作符”。

`null`值：如果查询时设置值为`null`，则查询不仅会返回对应键值为`null`的文档，还会返回没有对应键的文档。如果不希望返回这些缺少键的文档，可以使用`$exist`来判断键值对是否存在。

正则表达式：进行匹配的值可以是正则表达式，所有含有匹配正则表达式的对应键值的文档都会被返回。使用正则表达式进行查询之前最好在shell中进行正则表达式的验证来防止出现问题。

数组查询：如果有一个文档：

```json

{
  "fruit": ["apple", "banana", "peach"]
}

```

如果查询条件如下：

```json

{
  "fruit": "apple"
}

```

则之前的文档会成功匹配。即如上的查询条件意味着MongoDB会查找数组内部的值。但是如果查询条件如下：

```json

{
  "fruit": ["apple", "banana"]
}

```

或

```json

{
  "fruit": ["banana", "apple", "peach"]
}

```

都不会匹配所提供的文档。即值如果是数组的话会进行精确匹配，无论是缺项或者是乱序都不会匹配。

`$all`：`$all`可以接受一个数组作为查询参数，只要对应键的数组中包含该数组内所有值的文档就会作为结果返回。其中`$all`的数组参数的顺序是无关紧要的。

`$slice`：`$slice`可以限制返回的文档数。为正值时返回前面指定数目的文档，为负值时返回后面指定数目的文档。`$slice`还可以指定偏移，例如：

```json

{
  "comments": {
    "$slice": [23, 10]
  }
}

```

表示从第24个元素开始，返回10个文档，不足则全部返回。

数组和范围查询相互作用：例如文档：

```json

[
  {"x": 5},
  {"x": 15},
  {"x": 25},
  {"x": [5, 25]}
]

```

如果查询条件为：

```json

{
  "x": {
    "$gt": 10,
    "$lt": 20
  }
}

```

则结果会返回：

```json

[
  {"x": 15},
  {"x": [5, 25]}
]

```

匹配`{"x": [5, 25]}`的原因是`5`小于`20`且`25`大于`10`。

查询内嵌文档：如果直接进行查询的话需要内嵌文档完全一致（即和数组查询一样是精确匹配），而且不能针对内嵌文档进行范围等条件查询。使用`$elemMatch`来满足进行内嵌文档的查询。例如：

```json

{
  "comments":{
    "$elemMatch": {
      "author": "Joe",
      "score": {"$gte": 5}
    }
  }
}

```

可以查到评论中Joe 大于等于5分的评论。

## 4.4 $where查询

`$where`可以进行任何的查询。比较常用的是比较文档中两个键的值是否相等。但是如果非必要，务必不要使用`$where`进行查询。因为`$where`查询要比常规查询慢很多，`$where`查询会把每个文档从BSON转换为JavaScript对象，然后再进行查询，而且`$where`不能使用索引。如果必须使用`$where`，也尽量先用常规查询进行过滤再使用`$where`来查询。

## 4.5 游标

游标可以保存一次查询的结果并提供逐条查看结果。例如：

```js

var cursor = db.foo.find()

```

此时游标仅是保存了查询的构造，而并没有向服务器发起查询。在执行：

```js

cursor.hasNext()

```

后，查询请求才会到达服务器，返回查询结果。接下来的`cursor.next()`以及`cursor.hasNext()`均是在本地执行的。

针对返回结果的限制的方法有`limit`、`skip`、`sort`。`limit`可以限制返回结果数量，即最多返回指定数量的文档；`skip`可以略过指定数量的文档，如果结果收少于指定数量则不返回结果；`sort`可以按照指定的键值大小进行文档的排序，例如：

```js

db.c.find().sort({
  username: 1,
  age: -1
})

```

这表示针对`username`进行升序排列，针对`age`斤西瓜降序排列。这三种方法可以组合使用，链式写法即可。

此外，`sort`如果对类型不一致的键值进行排序时是有指定类型循序的：（1）最小值；（2）null；（3）数字（整型、长整型、双精度）；（4）字符串；（5）对象/文档；（6）数组；（7）二进制数据（8）对象ID；（9）布尔型；（10）日期型；（11）时间戳；（12）正则表达式；（13）最大值。

使用`skip`跳过大量的文档会变得很慢，因为这些需要略过的文档也需要被找出，然后再抛弃这些文档。

高级查询选项：如`find({"foo": "bar"}).sort({"x": 1})`在shell或者其它驱动程序中并不是直接发出`{"foo": "bar"}`这样的查询请求，而是将它们封装进更大的查询文档中，像这样：

```js

{
  "$query": {"foo": "bar"},
  "$orderby": {"x": 1}
}

```

此外还有一些其他的辅助查询操作，例如`$maxscan`（指定本次查询中扫描文档的上限）、`$min`（文档必须与索引的键完全匹配，并指定索引扫描的下边界）、`$max`（文档必须与索引的键完全匹配，并指定索引扫描的下边界）等。

像前文所说，MongoDB中文档是顺序存储的，如果对某个文档进行修改而使其体积变大，MongoDB会将其移动到所有文档后面存储，这种机制在查询时有可能出现多次返回该文档。由于游标同样是向后查询文档，如果在前面修改了某个文档导致其变大被移动到了后面，游标向后移动时会再次查询到该文档。解决这个问题需要对查询结果进行快照，这样查询就在`_id`索引上遍历执行，保证每个文档只返回一次。使用快照会使查询变慢，所以应该只在必要的时候使用快照。

游标的生命周期：在服务端，游标占用内存等资源。当游标遍历了所有结果或者客户端发来信息要求终止，数据库会释放游标占用的资源。当然，还有一些其他情况会使得游标被删除，例如如果客户端的游标已经不在作用域内时，客户端会发出一个特殊的消息要求服务端销毁游标，或者10分钟内某个游标没有使用的话也会删除。

## 4.6 数据库命令

数据库命令，例如`drop`，其实是一种特殊的查询，只不过服务端收到这类“查询”会进行特殊的逻辑处理。

# 5 索引

## 5.1 索引简介

索引可以根据给定字段组织数据，让MongoDB能够根据这些字段快速找到指定的文档。例如，为`username`创建索引：

```js

db.users.ensureIndex({"username": 1});

```

建立索引所耗时间根据机器性能以及文档整体大小的不同而不同。虽然建立索引之后查询几乎会瞬间完成，但是其他操作，包括插入、更新、删除等将会消耗更多时间，因为这些操作会修改集合的结构，从而导致需要修改建立的索引。因此，MongoDB也限制每个集合上最多有64个索引，一般来说，一个特定的集合上不应该有两个以上的索引。挑选合适的字段建立索引非常重要。如果某个字段是常用的查询字段，那么在这个字段上建立索引是一个好选择，反之则没有必要建立索引。

索引的值是按照一定的顺序排列的，因此索引键对文档进行排序非常快。但是如果查询时没有首先使用索引键进行排序时，索引并不会发挥作用。不过可以针对多个字段建立复合索引。建立复合索引时优先考虑需要排序的键，将其放在首位索引键。

索引的排序方式并不重要，因为MongoDB可以在索引的任意方向进行便遍历。

有一些查询操作完全无法使用索引，例如`$where`、`$exists`、`$nin`查询只能进行全表扫描，而`$ne`、`$not`多数情况下也会进行全表扫描。

`$or`查询实际上是两次查询，最后合并结果，这样的效率必然不如一次查询的效率高，因此尽可能使用`$in`代替。此外，MongoDB一次查询只能使用一个索引/复合索引，但是由于`$or`是两次独立的查询，所以它可以使用多个索引。

MongoDB可以针对嵌套文档的键建立索引，和建立普通的索引类似。例如文档：

```json

{
  "username": "sid",
  "loc": {
    "ip": "1.2.3.4",
    "city": "Springfield",
    "state": "NY"
  }
}

```

给`loc.city`建立索引：

```js

db.users.ensureIndex({"loc.city": 1});

```

即可。但是注意和子文档`loc`的索引进行区分。如果建立的索引是子文档的索引，那么只有如下的查询才会使用子文档索引：

```js

db.users.find({
  "loc": {
    "ip": "123.234.111.222",
    "city": "Shelbycille",
    "state": "NY"
  }
});

```

即必须与子文档字段顺序完全匹配的子文档查询才能使用子文档索引，而：

```js

db.users.find({"loc.city": "Shelbycille"});

```

才会使用子文档的键的索引。

同样可以给数组元素建立索引，但是不能给数组本身建立索引。给数组元素建立索引即给数组的每一个元素建立索引，因此数组索引的代价要高于单值索引的代价。并且，一个索引中的数组字段最多只允许有一个，以防止多个数组建立索引之后索引条目爆炸式增长。

多键索引：在索引中，如果某个键是数组，那么这个索引会被标记为多键索引。多键索引会比非多键慢一些，因为可能会有多个索引条目指向同一个文档，因此MongoDB在返回结果集时需要先去重。

索引基数：就是指某个字段对应不同值的数量。例如性别可能只有两种取值，这种字段的基数就比较低；像用户名、住址这类字段可能每个值和其他的都不一样，这类字段的基数就很高；也有介于两者之间的，例如年龄。通常情况下，一个字段的基数越高，那么对这个字段建立的索引越有价值，因为这个索引可以快速将查询范围缩小到一个比较小的结果集，以供下一步操作快速完成。因此建立索引应该选择基数高的字段，或者在复合索引中将基数高的字段提前。

## 5.2 使用explain()和hint()

`explain()`能够提供大量与查询相关的信息，其中返回的一些字段有助于发现查询速度慢的原因。以下列举一些字段：

（1）`cursor`：表示游标的类型。可以看出本次查询是否使用了索引以及使用的什么索引。

（2）`isMultiKey`：是否使用了多键索引。

（3）`n`：本次查询返回的文档数量。

（4）`nscannedObjects`：MongoDB按照索引指针去磁盘上查找文档的次数。如果查询包含的查询条件不是索引的一部分，或者要求返回的内容不在索引字段内，MongoDB就会从磁盘中读取原文档。

（5）`nscanned`：如果使用了索引，这个字段表示查找过的索引条目，如果没有使用索引，那么这个字段表示查找的文档数量。

（6）`scanAndOrder`：MongoDB是否对内存中的结果进行了排序。

（7）`indexOnly`：MongoDB是否只是用了索引就完成了此次查询，即包括查找字段以及返回的结果集都包含在索引中，又称覆盖索引。

（8）`nYields`：查询暂停次数，如果有写入请求，查询会周期性释放锁，以供写入执行。

（9）`millis`：查询所耗毫秒数。

（10）`indexBounds`：这个字段描述了索引的使用情况，给出了索引的遍历范围。

`hint()`可以指定查询使用的索引。

查询优化器：与关系型数据库不同，当有多个索引可能适合本次查询时，MongoDB的查询优化器会并行执行这些查询，最早返回100个结果的索引就是“胜者”，并且这个索引会被缓存，在接下来的这个查询都会使用这个索引。如果建立了新的索引或者每执行1000次查询后，查询优化器就会重新评估查询计划。`explain()`返回的`allPlans`字段表示了本次查询尝试的每个查询计划。

## 5.3 何时不应该使用索引

如果数据集较小时，索引会十分高效。但是当结果集在原集合中所占比例越大，索引查找的速度就越慢。因为使用索引需要进行两次查找，最坏情况下索引查找的时间是全表查找的两倍。一般来说，当查询需返回30%的文档或更多时，就需要对比索引查找和全表查找的速度。

## 5.4 索引类型

唯一索引：唯一索引可以确保集合的每一个文档的指定键都有唯一值。例如：

```js

db.users.ensureIndex({"username": 1}, {"unique": true});

```

这样可以防止有重复键的插入。但是如果有第一个没有该键的文档插入时，该键将被创建，值会置为`null`，如果继续插入缺少该键的文档就会报错。

进行索引的所有字段都应当小于1024字节，否则这个条目将不会出现在索引中。如果唯一索引的字段超过8KB，唯一索引将会失效。

可以创建复合的唯一索引，复合唯一索引中，单个键的值可以重复，但是所有键的值的组合必须在集合中是唯一的。

稀疏索引：区别与关系型数据库中的稀疏索引，这里的稀疏索引是指如果文档包含指定字段，则为这些文档建立索引。如果和唯一索引一起使用，则这些字段的值必须唯一。

## 5.5 索引管理

索引的元信息保存在`system.indexes`中，可以通过`db.collectionName.getIndexes()`来查看集合的索引。

索引的标识形如`keyname1_dir1_keyname2_dir2_..._keynameN_dirN`，索引标识也是有长度限制的。

如果需要删除索引，可以使用`dropIndex`。
