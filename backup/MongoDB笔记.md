# 1 MongoDB简介

+ MongoDB是一个面向文档的数据库，与传统的关系型数据库不同，MongoDB中没有行的概念，取而代之的是文档中的内容和数组。这种形式可以灵活的表现各种复杂的层次关系，加快开发者开发进程。

<!-- more -->

+ 当数据积累到一定程度，当前的服务器性能不足以胜任计算性能和存储空间要求时，应当进行数据库的纵向扩展或者横向扩展。纵向扩展是指单纯提高服务器的硬件性能，横向扩展是指向服务器集群中添加更多的服务器。显然纵向扩展是有极限的，而MongoDB可以进行较为方便的横向扩展，以提高数据库集群的计算能力以及存储空间。

+ MongoDB支持索引、聚合、特殊的集合类型、文件存储的功能，但是例如连接和复杂的多行事物等是不支持的，这是由于这些功能不方便在分布式系统上实现。

# 2 基础部分

## 2.1 文档

+ 文档是一组有序键值对的集合。注意：（1）键中不能含有`\0`（表示字符串结尾），`.`和`$`有特殊含义，不能随意使用；（2）键不能重复；（3）键字符串可以是任意utf-8符号。

## 2.2 集合

+ 集合是一组文档。虽然可以将不同结构的文档，但是出于方便管理、为集合建立索引以及查询性能的考虑，建议把同种结构、包括同类内容的文档归入同一集合内。这也是为什么设计集合的原因。

+ 类似于文档键的命名规则，集合名的命名规则有：（1）不能为`""`；（2）不能包含`\0`、`$`；（3）不能以`system.`开头，这些事系统集合的保留前缀。

+ 可以用`.`来进行子集合的组织，构成各种不同的集合子命名空间。

## 2.3 数据库

+ 数据库由多个集合组成。每个数据库都是独立的，无论是权限还是磁盘存储位置。

+ 与集合名、文档键名类似，数据库名也有相应的命名规则：（1）不能为`""`；（2）不能包含`\`、`/`、`*`、`"`、`<`、`>`、`|`、`?`、` `、`$`、`\0`，推荐使用ASCII中的字母和数字；（3）区分字母大小写，简单起见，均使用小写字母；（4）数据库名最长为64字节。

+ 有一些数据库名是保留的，它们有相应的功能：（1）admin：如果将一个用户加入该数据库，它将获得所有数据库的权限，另外有一些指令必须从admin数据库中启动；（2）local：所有本地的集合都会存到这个数据库中，此外，该数据库不能复制；（3）config：分片信息会保存到这个数据库中。

## 2.4 安装MongoDB以及启动

安装环境为CentOS 7。

添加官方源到`/etc/yum.repos.d/mongo-2.6.repo`：

```

[mongodb-org-2.6]
name=MongoDB Repository
baseurl=https://repo.mongodb.org/yum/redhat/$releasever/mongodb-org/2.6/x86_64/
gpgcheck=1
enabled=1
gpgkey=https://www.mongodb.org/static/pgp/server-2.6.asc

```

使用`yum`开始安装：

```shell

yum -y install mongodb-org

```

启动MongoDB服务：

```shell

systemctl start mongod

```

## 2.5 MongoDB shell

+ MongoDB的shell包含Google的V8引擎，可以执行JavaScript代码，支持JavaScript标准库。打开shell时将会自动连接到本地的MongoDB服务器，也可以指定连接到远端的MongoDB服务器。此外，MongoDB的shell也提供一些方便的语法糖，供习惯于SQL shell的用户使用。

## 2.6 数据类型

+ MongoDB中包含JSON中的几种基本数据类型，还包括了一些其他的扩展类型，以下举出常用的数据类型：
（1）null：空值或值不存在；
（2）布尔值：true或false；
（3）数值：shell中默认使用64位的浮点数，如果想表示整数，可以使用整数类`NumberInt`（4字节有符号整数）或`NumberLong`（8字节有符号整数）；
（4）字符串：utf-8的字符串；
（5）日期：`Date`类，使用`new Date()`创建；
（6）正则表达式：与JavaScript的正则表达式相同；
（7）内嵌文档：将一个文档作为另一个文档的值；
（8）对象id：`ObjectId`类，作为文档的唯一标识；
（9）数组：由一系列可以不同类型的数据构成。

+ 关于日期：如果不使用`new Date()`创建日期对象而使用形如`Date(...)`的构造函数，返回的将是字符串而不是毫秒数。

+ 关于内嵌文档：内嵌文档可以让数据存储更加自然、高效、立体。例如：

```json

{
  "name": "Joe",
  "address": {
    "street": "123 Park Street",
    "city": "X town",
    "state": "NY"
  }
}
```

如果将这段数据存入关系型数据库中，一般来说会拆分成复数个表，会比较复杂。但是，MongoDB如此做的缺点是造成数据冗余。例如某城市的拼写有误，在关系型数据库中只需要修改城市表中有误的项，而对于MongoDB来说则是对属于该城市的每个人的信息进行修改。

+ 关于`_id`：在MongoDB中，每个文档都必须有`_id`，其值可以是任意类型的任何值。在同一个集合的不同文档，其`_id`不能相同。

+ 关于`ObjectId`：这是一种轻量型生成ID的类，可以在不同的机器上使用同种方法生成全局唯一的ID。由于传统数据库中使用的自增主键很难在分布式数据库中同步生成，所以MongoDB采用了这种方法。

+ `ObjectId`构成：`ObjectId`占用12字节的空间，其中0-3字节是秒级的时间戳，标明文档的创建时间；4-6字节是机器名的hash值，以保证不同机器产生的`ObjectId`不同；7-8字节是PID，以保证在同一机器上并发的进程产生的文档的`ObjectId`不同；9-11字节是一个自增的计数器，以保证同一进程在1秒内创建的文档的`ObjectId`不同，一个进程在一秒内最多可以拥有2563个不同的`ObjectId`。

+ 插入文档时如果没有`_id`，系统会自动生成`ObjectId`。虽然可以由MongoDB服务器来做这件事，但通常是由客户端的驱动程序来完成。这体现了MongoDB的哲学理念：能交给客户端驱动程序做的事就不要交给服务器来做。因为扩展应用层比扩展数据库层简单很多，将部分工作交给客户端来完成，也能够减少服务器的负担。

## 2.7 MongoDB shell 的使用

+ 由于使用了V8引擎，MongoDB shell支持运行JavaScript代码，并且如果在启动MongoDB客户端时在`mongo`后面添加js文件，即可在shell可交互之前运行指定的js代码。如果有些js文件需要频繁运行，可以把这部分JavaScript代码写入一个名为`.mongorc.js`的文件，并放在用户主目录下；这时MongoDB shell运行时就会先执行`.mongorc.js`。

+ `mongorc.js`中，可以：

（1）创建需要的全局变量；
（2）简化过长的名字，为其起一个别名；
（3）重写内置函数；
（4）移除比较危险的函数，例如`dropDatabase`以及`deleteIndexes`,让它们不能执行，防止误操作。这条是比较常用的。

+ shell中的提示是可以定制的，例如在查询过程中显示时间以及显示当前使用的Da名。

+ 如果在shell中希望修改之前已经输入的行，可以在`.mongorc.js`中添加一行：

```js

EDITOR = "/usr/bin/vi"

```

如此，需要修改某个变量时可以输入`edit post`即可修改`post`变量。

+ shell与集合命名：如果集合名中包含JavaScript的保留字或者不允许的字符，将不能使用`db.collectionName`的形式来访问集合，需要使用函数`db.getCollection()`来代替，也可以使用类似于`db['collectionName']`来访问。


# 3 创建、更新和删除文档

## 3.1 插入并保存文档

+ 批量插入：除了使用`insert`插入单条数据，还可以使用`batchInsert`进行批量插入，它接受一个文档数组。MongoDB接受的最长消息为48MB，如果超过48MB，多数的驱动程序会将插入请求拆分成多个。如果在插入的过程中某个文档插入错误，则这个文档之前的文档均插入成功，之后的文档均插入失败。可以设置`continueOnError`参数，跳过插入有误的文档，继续进行插入。所有的驱动程序均支持该参数，但shell不支持。

+ 插入校验：插入文档时，会进行基本的数据校验，例如检查有没有`_id`字段，没有则会自动生成一个；会检查文档的大小，单个文档的大小不能超过16M，以防止不良的设计模式，保持性能的一致；会检查有误非utf-8字符存在等等。但尽管如此，向MongoDB中插入非法数据是十分容易的，所以应当只允许信任源连接数据库是必要的。

## 3.2 删除文档

+ 使用`remove()`进行文档删除时，会删除集合中的所有文档，但不会删除集合本身，以及集合的元信息。`remove()`也可以接受一个条件参数，来删除指定的文档。删除时永久性的，不可撤销，也不可恢复。

+ 使用`drop()`的删除速度要远远超过`remove()`，但是如此之后集合也会被删除，也不能指定条件。

# 3.3 更新文档

+ 更新`update()`可以接收两个参数，一个是查询条件，即需要修改哪个文档；另一个是需修改的内容。更新操作时不可分割的。如果有两个更新同时发生，则请求先到达服务器的先执行。系统则会保留最后的更新。`update`的第三个参数是`upsert`，类型为布尔值，为`true`则在查询过程中若没有找到符合条件的文档时会进行创建。第四个参数是是否修改查询得到的全部文档，默认为`false`，即只修改查询得到的第一个文档。

+ 默认情况下，`update`中需修改的内容会被认为是替换原有文档，但是如果希望仅针对文档中的某键值修改的话，可以使用修改器，例如：

```js

db.analytics.update(
  {"url": "www.example.com"},
  {"$inc": {"pageviews": 1}}
)

```

+ 不同的修改器修改文档的速度是不同的。例如只修改值的`$inc`修改器修改速度很快，因为不需要改变文档大小。但是可以修改文档大小的——例如`$set`——就会比较慢，由于MongoDB是给每个文档固定长度的存储空间，如果文档变大进而不能再原先位置存储，还需要移动的磁盘上的其他位置。文档有一个填充因子的参数，用于文档大小的增长。如果一个文档多次因变大而在磁盘上移动，则该文档的填充因子同样会增长。

+ 一个修改操作中不能含有多个修改器，例如在某个修改请求中同时含有`$inc`和`$set`，这个请求就是非法的。

+ 为防止多个线程/进程修改同一个文档而导致竞态，MongoDB提供了一个`findAndModify`方法，其查找和修改是原子操作，不会出现竞态。`findAndModify`不仅可以用于`update`，也可以用于`remove`。

+ 写入安全：分为应答式写入和非应答式写入。应答式写入是指客户端提出写入请求后等待服务端返回写入结果，非应答式写入则相反。

# 4 查询

## 4.1 find

+ 在MongoDB中，使用`find()`来进行查询操作。第一个参数是查询条件，类型为文档，其中包括希望返回结果满足的键值对的要求。如果有对个键值对，将视为“与”进行查询。

+ `find()`的第二个参数为希望返回/不返回的键，类型为文档，键即文档的键，值为1则返回该键值对，值为0则不返回该键值对。`_id`默认是返回的，如果不希望返回`_id`，可以使用`"_id": 0`。

## 4.2 查询条件

+ 除了精确查询以外，还可以使用`$lt`、`$lte`、`$gt`、`$gte`来进行范围查询，它们分别表示`<`、`<=`、`>`、`>=`。例如：

```json

{
  "age": {
    "$gt": 18,
    "$lt": 30
  }
}

```

上述查询条件表示查找键名`"age"`值大于18小于30的文档。另外，`$ne`表示不相等。

+ 关于`$in`、`$nin`：如果希望能查找某个键对应的多个值，可以使用`$in`。`$in`的参数为一个数组，数组中的值可以为任何类型，MongoDB会查找所有该键的值在数组中的文档。`$nin`则相反，会返回所有该键的值不在数组中的文档。

+ 关于`$or`：`$or`可以进行不同键的“或”查询。和`$in`类似，其参数为一个数组，不过数组中的值均为文档类型。文档中即普通的查询条件。

+ `$not`：`$not`会返回所有不符合参数中查询条件的文档。和`$and`、`$or`都被称为“元操作符”。

+ `null`值：如果查询时设置值为`null`，则查询不仅会返回对应键值为`null`的文档，还会返回没有对应键的文档。如果不希望返回这些缺少键的文档，可以使用`$exist`来判断键值对是否存在。

+ 正则表达式：进行匹配的值可以是正则表达式，所有含有匹配正则表达式的对应键值的文档都会被返回。使用正则表达式进行查询之前最好在shell中进行正则表达式的验证来防止出现问题。

+ 数组查询：如果有一个文档：

```json

{
  "fruit": ["apple", "banana", "peach"]
}

```

如果查询条件如下：

```json

{
  "fruit": "apple"
}

```

则之前的文档会成功匹配。即如上的查询条件意味着MongoDB会查找数组内部的值。但是如果查询条件如下：

```json

{
  "fruit": ["apple", "banana"]
}

```

或

```json

{
  "fruit": ["banana", "apple", "peach"]
}

```

都不会匹配所提供的文档。即值如果是数组的话会进行精确匹配，无论是缺项或者是乱序都不会匹配。

+ `$all`：`$all`可以接受一个数组作为查询参数，只要对应键的数组中包含该数组内所有值的文档就会作为结果返回。其中`$all`的数组参数的顺序是无关紧要的。

+ `$slice`：`$slice`可以限制返回的文档数。为正值时返回前面指定数目的文档，为负值时返回后面指定数目的文档。`$slice`还可以指定偏移，例如：

```json

{
  "comments": {
    "$slice": [23, 10]
  }
}

```

表示从第24个元素开始，返回10个文档，不足则全部返回。

+ 数组和范围查询相互作用：例如文档：

```json

[
  {"x": 5},
  {"x": 15},
  {"x": 25},
  {"x": [5, 25]}
]

```

如果查询条件为：

```json

{
  "x": {
    "$gt": 10,
    "$lt": 20
  }
}

```

则结果会返回：

```json

[
  {"x": 15},
  {"x": [5, 25]}
]

```

匹配`{"x": [5, 25]}`的原因是`5`小于`20`且`25`大于`10`。

+ 查询内嵌文档：如果直接进行查询的话需要内嵌文档完全一致（即和数组查询一样是精确匹配），而且不能针对内嵌文档进行范围等条件查询。使用`$elemMatch`来满足进行内嵌文档的查询。例如：

```json

{
  "comments":{
    "$elemMatch": {
      "author": "Joe",
      "score": {"$gte": 5}
    }
  }
}

```

可以查到评论中Joe 大于等于5分的评论。
